/*************************************************************
	Практическое занятие №3. Встроенные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/

#include <iostream> 
#include <cstdlib>
#include <cstring>

#define	  stop 

 

int main()
{

///////////////////////////////////////////////////////////////
//			Встроенные массивы                               //
///////////////////////////////////////////////////////////////

	//Задание 1. Объявите трехмерный массив и сформируйте указанные
	//значения элементов следующим образом:
	//а) проинициализируйте массив при объявлении
    
    
	//б) объявите неинициализированный массив и присвойте значения элементам //FIXME
     /*   int ar[3][3][3]; /* = {
                {
                    {1, 1, 1},
                    {1, 1, 1},
                    {1, 1, 1}
                },
                {
                    {2, 2, 2},
                    {2, 2, 2},
                    {2, 2, 2},
                },
                {
                    {3, 3, 3},
                    {3, 3, 3},
                    {3, 3, 3},
                }
        };
        
        int arSize = 3 * 3 * 3;
        
        for (int n0 = 0; n0 < 3; n0 ++) {
            for (int n1 = 0; n1 < 3; n1 ++) {
                for (int n2 = 0; n2 < 3; n2 ++) {
                    ar[n0][n1][n2] = (n0 + 1); 
                }
            } 
        }
        
        int *par = &ar[0][0][0];
        
        
        int sum = 0;
        for(int n = 0; n < arSize; n ++) {
            sum += *par;             
            par ++;
        }
        std::cout << "sum: " << sum << "\n";
	//	с помощью кода
	//					 |--------|		
	//				/ |3  3  3 |		
	//    			  |---------|3 |
        //			   / | 2  2  2 | 3 |
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__| 
	//			  | 1  1  1 | /
	//			  |_________|
	//Средствами отладчика проверьте правильность Вашего решения.

	//в) найдите сумму элементов массива
	 
       int ar2[3][3][3] = {
                {
                    {1}
                },
                {
                    {2}
                },
                {
                    {3}
                }
        };
	//г) проинициализируйте массив при объявлении:
	//					 |--------|		
	//				   / |3  0  0 |		
	//    			 |---------|0 |
    //			   / | 2  0  0 |0 |
	//			  |---------|0 |__|
	//			  | 1  0  0 |0 | /
	//			  | 0  0  0 |__| 
	//			  | 0  0  0 | /
	//			  |_________|
  


	//д) Инициализация массивов строковыми литералами:
	//Объявите и проинициализируйте строковыми литералами два массива:
	//двухмерный массив и массив указателей. Поясните разницу в использовании
	//элементов таких массивов.
       //массив массивов чаров
       char arChar[][4] = {
           {'a', 'b', 'c', 'd'},
           {'x', 'y', 'z',}
       };
       arChar[0][0] = 'z';
       
       //массив указателей на тип char
        const char * pArChar[] = {
           "abcd",
           "xyz"
       };



///////////////////////////////////////////////////////////////
//			Динамическое выделение памяти                    //
///////////////////////////////////////////////////////////////
	//Задание2. Создайте динамический двухмерный массив с размерностями,
	//вычисляемыми в процессе выполнения программы - N*M.
	//Задайте значения элементов помощью генератора случайных чисел.
	//Найдите  сумму элементов.
	//Подсказка 1: для генерации случайных чисел используйте функцию
	//стандартной библиотеки - rand() (<cstdlib>)
	//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
	//чисел являются «псевдослучайными», то есть при двух последовательных запусках
	//приложения Вы получаете две одинаковые последовательности значений.
	//Для того чтобы генерируемые "случайные" значения были разными при каждом 
	//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
	//и time() (<ctime>).
	//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
	//Функция time() задает эту точку отсчета, считывая текущее время
	
	//srand(time(0));
        unsigned const int MAX = 100;
        unsigned  int N = 1+ rand() % MAX, M = 1+ rand() % MAX; 
     
        std::cout << "Make array: N: " << N << ", M: " << M << "\n";
        int **pDAr = new int*[N];
        
        for(int i = 0; i < N; i ++) {
            int *ar = new int[M];
            for (int j = 0; j < M; j ++) {
                ar[j] = rand() % MAX;
            }
            pDAr[i] = ar;             
        }
        
        sum = 0; 
         for(int i = 0; i < N; i ++) {
             for(int j = 0; j < M; j ++) {
                sum += pDAr[i][j]; 
             } 
         }
        std::cout << "sum: " << sum << "\n";
        
        
        


	//Задание2а. В сформированном массиве отсортируйте каждую строку по
	//убыванию значений. Используйте сортировку "выбором"
        for(int i = 0; i < N; i ++) {
            std::cout <<   i << ": "; 
             for(int j = 0; j < M; j ++) {
                std::cout << pDAr[i][j] << ","; 
             } 
             std::cout <<   "\n"; 
         }
        
        for(int i = 0; i < N; i ++) {
            int *pAr = pDAr[i];
            
            for(int j = 0; j < M; j ++) {
                int min = j;
                
                for (int n = j + 1; n < M; n++) {
                    if (pAr[n] < pAr[min])  {
                        min = n;
                    }
                }
                
                int dummy = pAr[j];
                pAr[j] = pAr[min];
                pAr[min] = dummy;
            }
        }
        for(int i = 0; i < N; i ++) {
             std::cout <<   i << ": "; 
             for(int j = 0; j < M; j ++) {
                std::cout << pDAr[i][j] << ","; 
             } 
             std::cout <<   "\n"; 
         }
        
        
 

	//Задание2б. Объявите одномерный массив размерностью N.
	//Сформируйте значение i-ого элемента одномерного массива  
	//равным среднему значению элементов i-ой строки
	//двухмерного массива
        double *arAVG = new double[N];
        for(int i = 0; i < N; i ++) {
            int sum = 0;
             for(int j = 0; j < M; j ++) {
                sum += pDAr[i][j]; 
             } 
            arAVG[i] = (1.0 * sum / M);
            //std::cout << arAVG[i] << "\n";
         } 
        delete [] arAVG;
        
        

	//Подсказка - не забудьте освободить память!
        for(int i = 0; i < N; i ++) {
            delete[] pDAr[i];
        }
        delete[] pDAr;




	
	/////////////////////////////////////////////////////////////////////
	//Задание 3. а) Напишите фрагмент кода, который вводит NN целых чисел с помощью
	//потока ввода в объявленный Вами встроенный одномерный массив, каждый раз
	//упорядочивая полученное значение по возрастанию
	 
        int inInt, count = 0;
        int const inIntArLen = 1024;
        int inIntAr[inIntArLen]; 
        while(count < inIntArLen && (std::cin >> inInt)) {
            std::cout << "input: " << inInt << "\n";
            
            bool isset = false;
            for (int j = 0; j < count; j ++) {
                if(inIntAr[j] == inInt) {
                    isset = true;
                    break;
                }
            }
            
            if(isset) {
                std::cout << "Value already exists...\n";
                continue;
            }
            
            inIntAr[count ++] = inInt; 
            for(int j = 0; j < count; j ++) {
                int min = j;
                
                for (int n = j + 1; n < count; n++) {
                    if (inIntAr[n] < inIntAr[min])  {
                        min = n;
                    }
                }
                
                int dummy = inIntAr[j];
                inIntAr[j] = inIntAr[min];
                inIntAr[min] = dummy;
            }
            
            std::cout << "\nList: ";
            for(int j = 0; j < count; j ++) {
                std::cout << inIntAr[j] << ",";
            }
            std::cout << "\n";
        } 
        


	//б) Простой поиск.
	//Модифицируйте предыдущее задание следующим образом:очередное значение
	//вводится в массив только при условии, что там еще такого нет (то есть 
	//дубли игнорируются


	 

	///////////////////////////////////////////////////////////////////////////
	//Задание 4.С помощью данной заготовки напишите программу,
	//которая:
	//вводит строки с клавиатуры с помощью cin>>...
	//в объявленный Вами двухмерный встроенный массив 5*80 элементов типа char;
	//признаком конца ввода является символ * (то есть строка - "*") или
	//заполнение массива (больше свободных строк нет);
	//сортировка строк в алфавитном порядке. Пояснение: крайне
	//не рекомендуется для сортировки сложных объектов физически
	//перемещать их в памяти. Намного эффективнее завести массив
	//указателей на соответствующие строки и перемещать только
	//указатели.

    //Подсказка: для лексиграфического сравнения строк пользуйтесь
	//функцией стандартной библиотеки strcmp(...), заголовочный файл <string>.

	
	//Определите необходимые значения как константы
 //STOP_STRING  -  "*"	//признак "прекратить ввод"
        const char STOP_STRING = '*';
 //M  -  80	//максимальный размер одной строки
        const int M2 = 80;
 //N  -  10	//максимальное количество строк в массиве
	const int N2 = 10;


	//Объявите двухмерный массив с именем cBuffer типа char и
        
	// размерностью N*M
        char cBuffer[N2][M2];


	//Объявите массив (с именем cPointers) указателей на строки
	//размерностью N
         char* cPointers[N2];


	//Цикл ввода строк:
	//а) выведите приглашение для ввода
        std::cout << "Давайте введем данные:\n";

	//б) пока не введена строка STOP_STRING или не заполнен весь массив

	{ 
            int c = 0;
            char w;
            int i = 0;
            while((std::cin >> w) && w != STOP_STRING && c ++ < N2 * M2) {
                //cin.getline(buff, M); //
               // std::cout << "Вы ввели: " << *w << "\n" ;
                int j = c % M2;
                if(j == 0) {
                    i ++;
                }
                cBuffer[i][j] = w ; 
                
                //std::cout << i << ":" << j << "\n";
            }
		//ввод строки в массив cBuffer:
								
		//если введена строка - признак окончания, то выйти из цикла

		//Присвойте элементу массива cPointers с индексом nIndex
		//указатель на строку с номером nIndex в массиве cBuffer
            for(int i = 0; i < N2; i ++) {
                cPointers[i] = &cBuffer[i][0];
                std::cout << "N:" << i << ": " << cPointers[i] << "\n";
            } 

	}


	//Выдать диагностику о том, что прием строк завершен.

        std::cout << "Ввод завершен\n";
        std::cout << "Начинаем сортировку\n";

	//Теперь сортируем строки:
      ////////
        for (int i = 0; i < N2; i++) {
            for (int j = i +1; j < N2; j++)  { 
                if(strcmp(cPointers[i], cPointers[j]) > 0) {
                    char *ptemp = cPointers[j];
                    cPointers[j] = cPointers[i];
                    cPointers[i] = ptemp;
                }    
            } 
            
            for(int n = 0; n < N2; n ++) { 
                std::cout << "N: "  << n << ": "  << cPointers[n] << "\n";
            }
        } 
        
        //
            
        for(int i = 0; i < N2; i ++) { 
            std::cout << "N: "  << i << ": "  << cPointers[i] << "\n";
         }
    
	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания. На каждой итерации - промежуточная печать 
	//отсортированных строк


*/

	//Задание 5. Реализуйте задание №4, используя не встроенные,
	//а динамические массивы (массив?). Так как строки могут быть разной длины,
	//эффективным решением было бы отводить под каждую строку ровно столько байтов,
	//сколько требуется для ее хранения.
	//При этом необходимые параметры (количество строк
	// сформируйте с помощью потока ввода
	int nStringNumber;

        std::cout << "Введите длинну строки: \n";
	std::cin >> nStringNumber;
        std::cin.ignore();
        if(nStringNumber) {
            char **pcBuffer = new char*[nStringNumber];
          
            
            std::cout << "ввод данных: \n";
            //Цикл ввода строк:
            
            int row = 0; 
            char localBuf2[1024];
            while(row  < nStringNumber) { 
                
                std::cin.getline (localBuf2, 1024);
                  
                int size = strlen(localBuf2);
                
                for(int m = 0; m < size; m ++){
                    if(localBuf2[m] ==  '*') {
                        size = 0;
                        break;
                    }
                }
                if(size <= 0) {
                    break;
                }
                
                
                pcBuffer[row] = new char[size + 1];
                for(int m = 0; m <= size; m ++){
                    pcBuffer[row][m] = localBuf2[m];
                }
                row ++;
            }
            
           
            //Теперь сортируем строки:
             ////////
            for (int i = 0; i < row; i++) {
              for (int j = i +1; j < row; j++)  { 
                  if(strcmp(pcBuffer[i], pcBuffer[j]) > 0) {
                      char *ptemp = pcBuffer[j];
                      pcBuffer[j] = pcBuffer[i];
                      pcBuffer[i] = ptemp;
                  }    
              } 

              for(int n = 0; n < row; n ++) { 
                  std::cout << "N: "  << n << ": "  << pcBuffer[n] << "\n";
              }
            } 
            
            
            //free
            for(int j = 0; j < row; j ++) {
                std::cout <<  pcBuffer[j] << "\n";
                delete[] pcBuffer[j];
            }
            
            delete[] pcBuffer;
        }

  
	

  
	

  


	//Цикл сортировки строк методом "всплывающего пузырька" в
	//порядке возрастания кода первого символа

  
	
	  
		
	//Освобождение занятой памяти:




/**/


	//Задание 6. Объявление и использование указателей на многомерные
	// массивы. Проинициализируйте трехмерный массив
	//double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
	//кода, который меняет местами значения элементов четных
	//и нечетных слоев:
	//	было:			     |--------|		
            //  				   / |4  4  4 |		
	//					 |--------|	4 |	
	//				   / |3  3  3 |	4 |	
            //    			 |---------|3 |   |
        //			   / | 2  2  2 |3 | /
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__| 
	//			  | 1  1  1 | /
	//			  |_________|

        double dArray[4][3][3] = {
            {
                {1,1,1},
                {1,1,1},
                {1,1,1}        
            },
            {
                {2,2,2},
                {2,2,2},
                {2,2,2}
            },
            {
                {3,3,3},
                {3,3,3},
                {3,3,3}
            },
            {
                {4,4,4},
                {4,4,4},
                {4,4,4}        
            }
        };
        
        
	//	стало:			     |--------|		
	//  				   / |3  3  3 |		
	//					 |--------|	3 |	
	//				   / |4  4  4 |	3 |	
	//    			 |---------|4 |   |
    //			   / | 1  1  1 |4 | /
	//			  |---------|1 |__|
	//			  | 2  2  2 |1 | /
	//			  | 2  2  2 |__| 
	//			  | 2  2  2 | /
	//			  |_________|

	for(int i=0; i < 3; i += 2)
	{
	//Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
		double (*p1)[3] =  dArray[i];
		double (*p2)[3] =  dArray[i+1];//FIMXE
                //... =  dArray[i+1];
		//переставляем местами элементы i-того и i+1-ого слоев
            //double **t1 = new double*[3];
           // double t1 [3][3];
         //   t1  =  dArray[i];
           /* for(int x = 0; x < 3; x ++) {
                for(int y = 0; y < 3; y ++) {
                    double tmp = dArray[i + 1][x][y];
                    dArray[i + 1][x][y] = dArray[i][x][y];
                    dArray[i][x][y] = tmp;
                }
            }*/
                
                for(int j = 0; j < 9; j ++) {
                    double tmp = *p1[j];
                    *p1[j] = *p2[j];
                    *p2[j] = tmp;                    
                }             

	}
/*	*/

	///////////////////////////////////////////////////////////////////////////
	//Задание 7а. Объявите двухмерный встроенный массив элементов типа char.
	//Сформируйте значения элементов массива с помощью генератора случайных 
	//чисел таким образом, чтобы в массиве были только символы '*' и '_'  
	

	//В каждой строке "сдвиньте звездочки" в начало строки, например:
	//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
	//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
	//и распечатайте массив по строкам - "постройте распределение"
        
        const int R1 = 5,  C1 = 8;
        char arChars[R1][C1];
        
        for(int i = 0; i < R1; i ++) {
            for(int j = 0; j < C1; j ++) {
               arChars[i][j] = (rand() & 0x1) > 0 ? '*' : '_';
            }
        }
        
        //show
        for(int i = 0; i < R1; i ++) {            
            for(int j = 0; j < C1; j ++) {
               std::cout << arChars[i][j];
            }
            std::cout << "\n";
        }
        for(int i = 0; i < R1; i ++) { //int *p = arChars[i];            
            for(int j = 0; j < C1; j ++) {
                for(int n = j + 1; n < C1; n ++) { 
                            
                    if(arChars[i][j] != arChars[i][n] && arChars[i][j] == '*') {
                        char ptemp = arChars[i][j];
                        arChars[i][j] = arChars[i][n];
                        arChars[i][n] = ptemp;
                    } 
                }
            } 
        }
        //show
        for(int i = 0; i < R1; i ++) {            
            for(int j = 0; j < C1; j ++) {
               std::cout << arChars[i][j];
            }
            std::cout << "\n";
        }
        
        
        
   

/**/


	// 7б. Модифицируйте предыдущее задание следующим способом:
	//После заполнения массива с помощью генератора случайных чисел
	//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
	//"распределение"
        for(int i = 0; i < R1; i ++) {            
            for(int j = 0; j < C1; j ++) {
                for(int n = j + 1; n < C1; n ++) { 
                            
                    if(arChars[i][j] != arChars[i][n] && arChars[i][j] == '_') {
                        char ptemp = arChars[i][j];
                        arChars[i][j] = arChars[i][n];
                        arChars[i][n] = ptemp;
                    } 
                }
            } 
        }
        //show
        for(int i = 0; i < R1; i ++) {            
            for(int j = 0; j < C1; j ++) {
               std::cout << arChars[i][j];
            }
            std::cout << "\n";
        }

	return 0;
}