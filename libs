#pragma once

#include <iostream>
#include <vector>
#include <list>
#include <typeinfo>
#include "Point.h"

//
template <class T> 
void vectorInfo(std::vector<T> v) {
    std::cout  << "size( ): " << v.size( ) 
        << "; capacity(): " << v.capacity() 
        << "; max_size(): " << v.max_size() << std::endl;
}

//
template <class T> 
void vectorPrint(std::vector<T> v) {
    for(int i =0;i<v.size(); i ++) {
        std::cout << "v.at(" << i << ") " << v.at(i) << std::endl;
    } 
}

// 
template <class T> 
void vectorPrint(std::vector<std::vector<T>> v) {
    for(int i =0;i<v.size(); i ++) {
        std::cout << "Row v.at(" << i << ")" << std::endl;
        vectorPrint(v.at(i));
    } 
}

//
template <class T> 
void listPrint(std::list<T> l) {
    for (T n : l) {
        std::cout << n << std::endl;
    }
}

//
void listPrint(std::list<Point> l) {
    for (Point n : l) {
        std::cout << "Point{x:" << n.getX() 
                << ", y:" <<  n.getY() << "}" << std::endl;
    }
}

// 
void vectorPrint(std::vector<Point> v) {
    for(int i =0;i<v.size(); i ++) {
        std::cout << "v.at(" << i << ") Point{x:" << v.at(i).getX() 
                << ", y:" <<  v.at(i).getY() << "}" << std::endl;
    } 
}

//
template <class T> 
void itPrint(T cont) { //TODO ref
    auto it = cont.begin(); //Cbegin
    
    std::cout << "=================== " << typeid(cont).name() 
             << " ==================="  << typeid(it).name()  
            << " ===================" << std::endl;
    
    while(it != cont.end()) {
        std::cout << *it << std::endl;
        it ++;
    }
}


//
template <class T, class C> 
void dequeRemoveIF(std::deque<T> &deque, C cond) {
     auto it = deque.begin();
     while(it != deque.end()) {
        if(cond(*it)) {
            deque.erase(it);
        }
        ++ it;
    }
}

//
void vectorPrint(std::vector<Point*> v) {
    
    for(int i =0;i<v.size(); i ++) {
        std::cout << "v.at(" << i << ") Point{x:" << v.at(i)->getX() 
                << ", y:" <<  v.at(i)->getY() << "}" << std::endl;
    } 
}


//
template <class T> 
void removeUnique(std::vector<T> &v) {
    int n = 0, j;
    while(v.size() > n) {
        j = n + 1;
        while(v.size() > j) {
            if(v.at(n) == v.at(j)) {
                v.erase(v.begin()+j, v.begin()+j+1); 
            } else {
               j ++; 
            } 
        }
        n ++;
    }
}


//
template <class T> 
void removePair(std::vector<T> &v) {
    T last;
    int n = 0, s = 0;
   /* for(std::vector<T>::iterator it = v.begin(); it != v.end(); ++it)*/
    
    while(v.size() > n) {
        if(n == 0 || v.at(n) != last) { //первый раз или новый элемент
            last = v.at(n);
            s = n; 
            n ++; 
        } else  {
            while(v.size() > n && v.at(n) == last) {     //удаляем последовательности   
                n ++;
                v.erase(v.begin()+s, v.begin()+n);                            
            } 
            n = s; //встаем на место откуда начали удалять
            
        }   
    }     
}


//
template<class T>
void myReverse(T first, T last)
{
    while ((first != last) && (first != --last)) {
        std::swap(*first++, *last);
    }
}