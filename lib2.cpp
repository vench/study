/*************************************************************
	Практическое занятие №2. Побитовые операторы.
							Директивы препроцессора.
-							Указатели.
*************************************************************/
#include <cmath>
#include <iostream> 


#define	  stop 	//с помощью директивы препроцессора задаем
							//макроподстановку


//math len circul
#define LEN_CIRCUL(R) (M_PI * (R + R))

#define VAR_MAX(A, B) (A > B ? A : B)

#define EXCHANGE(X, Y) X = X + Y; Y = X - Y; X = X - Y;


#if defined _DEBUG 
#include "1.h"
#else
#include "2.h"
#endif


int main()
{
// ********************************************************
	//Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
	//1.1
	{
	int y;//Задайте значение y, например, с помощью потока ввода
        std::cout << "Задайте значение y:";
        std::cin >> y;
        
        if(y) {
            int i = 32;
            while(i -- > 0) {
                std::cout << ((y & (1 << i)) > 0 ? 1 : 0);
            }
            std::cout << "\n";
        }
        
         if(y) {
            int i = 32;
            bool start = false;
            
            while(i -- > 0) {
                int val = y & (1 << i);
                if(start || (val > 0 && y > 0) || (val <= 0 && y < 0)) {
                   start =  true;
                   std::cout << (val > 0 ? 1 : 0); 
                }
                
            }
            std::cout << "\n";
        }
        
	//С помощью побитовых операторов и операторов сдвига выведите значение "y"
	//на консоль в двоичном виде, например:
	//если y==9, то
	// а) 0 0 0 0 ...   0 0 1 0 0 1 (всего 32 двоичных цифры)
	


	// б) пропустите незначащие нули -  1 0 0 1



	}
	

	//1.2 Дана целая переменная
	{
		int y;//Задайте значение y, например, с помощью потока ввода

		//"Сдвиньте" все единицы в сформированном значении вправо, например:
		//было:   0100 1111 0000 0000 0110 1111 0000 0010
		//стало:  0000 0000 0000 0000 0000 1111 1111 1111
		//Реализовать задачу посредством одного цикла!
                 
                std::cin >> y;
                
                if(y) {
                    for(int i = 0; i < 16; i ++) {
                        y >>= 1;
                    }
                    std::cout << y << "\n";
                }

	}


	//1.3 Какие операции следует применить к заданному ниже операнду sNum для
	//того, чтобы переменная sRes приняла требуемое значение?
	//Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
	//использовать один оператор (и при необходимости маску) 
	//Замечание 2: посредством оператора xor (подобрав соответствующую маску)
	//можно получить любое значение => этот оператор предполагается использовать
	//в том случае, когда все остальные уже "не спасают" 
	{
             
	short sNum = 0x8008;//1000000000001000
	short sRes; 
        
        sRes = ~sNum;
	//0x7ff7 // 111111111110111
        
	sRes = sNum | 0x0ff0; 
	//0x8ff8 //1000111111111000
        
        sRes = sNum & 0x0008 ;
	//0x0008 //1000

        sRes = sNum ^ 0xff00; 
	//0x7f08 //0111111100001000  
                
        //todo        
        sRes = sNum >> 3;
	//0xf001 // 1111000000000001 
        sRes = sNum << 1;
	//0x0010 // 10000
        
	}

	stop
// ********************************************************
	//Задание 2. Директивы препроцессора

	//2.1. Использование "математических" макросов стандартной библиотеки:
	//в заголовочном файле <cmath> (который в свою очередь включает старый
	//файл math.h) определены часто используемые математические
	//константы, например M_PI. Воспользуйтесь этой константой для
	//вычисления длины окружности.
	//Обратите внимание: определения констант в свою очередь тоже заключены
	//в директивы условной трансляции. Что еще, кроме подключения заголовочного
	//файла, требуется сделать???
        {
            int r;
        //M_PI
            std::cout << "Введите радиус";
            std::cin >> r;
            
            if(r) {
                double l = M_PI * (r + r);
                std::cout << "Длинна круга: " << l << "\n";
                
                std::cout << "V2: Длинна круга: " << LEN_CIRCUL(r) << "\n";
            }
        }

	
	//2.2.Макросы с параметрами.
	//2.2.1 Напишите свою макроподстановку LENGTH которая вычисляет длину окружности.
	// протестируйте написанный макрос для следующих ситуаций:
	{
		//float l1 = LENGTH(1 + 2); // должно быть 18.8495...
		//float l2 = 1 / LENGTH(2); // должно быть 0.07957...
            float l1 = LEN_CIRCUL(1 + 2);
            std::cout << "L1: " << l1 << "\n";
            
            float l2 = 1 / LEN_CIRCUL(2);
            std::cout << "L2: " << l2 << "\n";
	}




	



	//2.2.2 определите макрос MAX(A, B)  для вычисления б'ольшего
	//значения из двух.
	
	//Используйте макрос следующим образом. Следите за изменением
	//значений переменных k, i, j. Объясните результат.
	//Постарайтесь убрать побочные эффекты.
	//Отметьте случаи, когда избежать побочных эффектов невозможно
/*
	int i = 10, j = 12, k;
	k = MAX(i, j);
	k = MAX(j, i) * 2;
	k = MAX(j, i+3);
	k = MAX(i--, j++);
*/

        //VAR_MAX
        int i = 10, j = 12, k;
	k = VAR_MAX(i, j);
        std::cout << k << "\n";//12
	k = VAR_MAX(j, i) * 2;
        std::cout << k << "\n";//24
	k = VAR_MAX(j, i+3);
        std::cout << k << "\n";//13
	k = VAR_MAX(i--, j++); // постфиксные операторы
        std::cout << k << "\n";//13
        
        
	//2.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
	//двух объектов типа int в памяти местами. Проверьте для приведенного
	//фрагмента. Подумайте, что будет делать макроподстановка, если
	//переставляемые значения разного типа???
	
/**/
	int x1=1, y1=-1;
	EXCHANGE(x1,y1);
        std::cout << "x1(1)=" << x1 << ", y1(-1)=" << y1 << "\n"; 

	int x2=100, y2=-100;
	EXCHANGE(x2,y2);
        std::cout << "x2(100)=" << x2 << ", y2(-100)=" << y2 << "\n"; 
        
        float fx2=-100;
	EXCHANGE(y2,fx2);
        std::cout << "y2(100)=" << y2 << ", fx2(-100)=" << fx2 << "\n"; 


/*
	//2.3. Директивы условной трансляции
	//Выполняя следующий фрагмент, посмотрите, какое
	//значение принимает переменная iNN. Что нужно сделать
	//для того, чтобы результат был равен 0? 1? 2?

int iNN;
#if defined NNN && defined MMM
	iNN = 0;
#elif defined MMM
	iNN = 1;
#elif defined NNN 
	iNN = 2;

#else
	iNN = -1;
#endif
	
	stop
*/
        int iNN;
        
#define NNN
#define MMM
        
#if defined NNN && defined MMM
	iNN = 0;
#elif defined MMM
	iNN = 1;
#elif defined NNN 
	iNN = 2;

#else
	iNN = -1;
#endif
        
        
        std::cout << "iNN: " << iNN << "\n";
//если объявить NNN  и  MMM , то 0
//если объявить только 	NNN , то 2
//если объявить только 	MMM , то 1
	stop
	


	//Задание 2.4. Загляните в Project/Properties -> диалоговая панель
	//- Property Pages/C\C++/Preprocessor/Preprocessor definitions.
	//В опциях командной строки в зависимости от мишени сборки проекта
	//(Debug или Release) может быть определено с помощью ключа /D
	//имя _DEBUG. С помощью директив условной
	//трансляции напишите фрагмент кода, который в зависимости от типа
	//мишени выводит с помощью cout разный текст на консоль. Проверьте
	//при разных мишенях сборки.

	//Пусть
	//для мишени Debug в процессе выполнения данного участка
	//кода на экран выводится информация об
	//имени файла, номере строки с функцией вывода, дате и времени 
	//компиляции файла, содержащего данную функцию вывода,
	//а также имя функции, содержащей данную строку.

	//Для мишени Release должна быть просто выведена строка
	//"Release configuration!"

	//Подсказка: для получения нужной информации введите в инструментальном
	//окне 'Index' справочной системы следующую ключевую фразу:	Predefined Macros
	
	//Подсказка: мишень сборки проекта можно
	//поменять следующим образом - Build/Configuration Manager/Configuration


#if defined _DEBUG
        std::cout  
                << "Вebug info:\n"
                << "\tFile: " << __FILE__ << "\n"
                << "\tLine: " << __LINE__ << "\n"
                << "\tFunction: " << __FUNCTION__ << "\n"
                << "\tDate: " << __DATE__ << "\n"
                << "\tTime: " << __TIME__ << "\n"
                ;
#else 
         std::cout << "Release configuration!" << "\n";
#endif
         


	//Задание 2.5. Управляя определенностью идентификатора _UNICODE и используя
	//возможности заголовочного <tchar.h>, объявите и проинициализируйте переменную,
	//которая может становиться как однобайтовой, так и расширенной без 
	//изменения исходного текста.
	//С помощью отладчика проверьте результат.

         //TODO 





// ********************************************************
	//Задание 3.Заголовочные файлы. Директива #include
	//3.1.Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
	//В каждом заголовочном файле объявите перечисление с одинаковыми именами
	//констант, но сопоставьте именованным константам разные значения, например:
	//1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
	//С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
	//констант из 1.h, а в RELEASE-версии значениями констант из 2.h


         std::cout << "MyEnum.My1: " << My1 << "\n";
         std::cout << "MyEnum.My2: " << My2 << "\n";
         std::cout << "MyEnum.My3: " << My3 << "\n";
// ********************************************************
/*
	//Задание 4. Указатели
	//Объявите объекты разных типов и проинициализируйте их.
	//Объявите указатели соответствующих типов и проинициализируйте их
	//адресами заданных объектов. 
	//Выполняя задание, с помощью отладчика посмотрите, какие значения
	//будут присвоены переменным-указателям и на что эти указатели
	//"указывают"
*/

     bool tb = false;
     int ti = 2017;
     float tf = 134.212;
     double td = 321.11112121212129;
     char * tc = "some text...";
     
     bool * ptb = &tb;
     int *pti = &ti;
     float *ptf = &tf;
     double *ptd = &td;
     char ** ptc = &tc;  
     
     
     
/*
	//Задание 4а. Объявите указатель на тип char и проинициализируйте
	//его адресом строкового литерала. Присвойте переменной типа char значение
	//любого элемента строки.
	//Проверьте - возможно ли присвоить какое-либо значение по адресу,
	//задаваемому указателем?


	stop
*/
     
     char *pCharTest = "Some test...";
     char vCharTest = pCharTest[5];
     std::cout << vCharTest << "\n";
   //  pCharTest[5] = 'A';//Segmentation fault;
     
     std::cout << "pCharTest: " << pCharTest << "\n";
     
     


	//Задание 5. Арифметика указателей. Операция разыменования указателя.
	//Выполняя задание, следите за изменением значений
	//указателей и значений объектов, на которые они указывают.
	//Интерпретируте наблюдаемые результаты
	{
		int nAr[3] = {1,3};//инициализирован массив из 3х эл 1,3,0
		int* pn = &nAr[0]; //взяли указатель на первый элемент массива
		(*pn)++;	// пребавили к первому эл массива 1
		pn++;	//передвинули указатель на 1 шаг вперед (элемент массива 2  - индекс 1)

		char cAr[]={'A','B','C','D'};//инициализирован массив из 4 чаров
		char* pc = &cAr[0];//взяли указатель на первый элемент массива
		(*pc)=(*pc)+5;	// A(66) + 5 = F(70) изменили значение 1 элемента
		pc=pc+3;//сместили указатель на 3 шага (D)	
	
		double dAr[3]={1.0,2.0};//инициализированли массив double 3 - 1, 2, 0
		double* pd1 = &dAr[0];//взяли указатель на первый элемент массива
		double* pd2 = pd1;//передали адрес указател я pd1 в  pd2
		(*pd2)+=2; // прибаили к значению массива 1 2
		pd2+=2;//сместили указатель на 3 эл массива

		//Объясните результат выполнения операции
		//вычитания двух указателей
		pd1 = &dAr[0];
		pd2 = &dAr[1];
		int nNumber=pd2 - pd1;
                std::cout << "nNumber: " << nNumber 
                        << "; pd1: " << ( pd1 > pd2 ? ">" : "<=" ) 
                        << " pd2: " << "\n";
		//Сравните указатели pd2 и pd1 и с помощью cout
		//выведите результаты сравнения.

		stop
	}
/**/

	//Задание 6. Явное преобразование указателя. Иногда возникает
	//необходимость одни и те же данные интерпретировать по-разному,
	//например, целое можно представить как совокупность четырех
	//байтов и работать с каждым байтом по отдельности. Для этого
	//нужно иметь возможность "указывать" как на целое, так и на байт. 
	//Следовательно, возникает необходимость явного преобразования
	//указателя. 
	//Подсказка: для правильной интерпретации этого задания воспользуйтесь
	//возможностями отладчика представлять данные в интересующем
	//Вас виде (в данном случае - в шестнадцатеричном) - для
	//этого используйте правую клавишу мыши,находясь в окне
	//переменных и изменяйте пункт - Hexadecimal display

    unsigned int nObject5=0x55667788;//1010101 01100110 01110111 10001000
	unsigned int* pnObject5=&nObject5;

	//Раскомментировав следующую строчку кода, обратите внимание
	//на сообщение компилятора - он не считает преобразование 
	//"легальным" (безопасным)
	unsigned char* pucObject5;
	//pucObject5=static_cast<unsigned char*>(pnObject5);	//(1)
        //invalid static_cast from type ‘unsigned int*’ to type ‘unsigned char*’
	pucObject5=reinterpret_cast<unsigned char*>(pnObject5);	//а такое
				//преобразование - целиком на совести программиста.
				//Его можно применять, только четко представляя себе
				//результат преобразования (2)
        //переводим указатель к другому типу

	//Откомментируйте следующие строчки сс==..., p - изменился? *p=...
	char cc = *(pucObject5++);//сместил указатель на 1 шаг и разименовывает его получаем значение первого байта
        //cc = 10001000
        
	cc = (*pucObject5)++;//разименовываем текущее значение по указателю (2 байт)
        //и увеличивем его на 1
        //cc = 01110111
        
	cc = ++*(pucObject5);//разименовываем текущее значение по указателю и увеличивем его на 1 (до присвоения в cc)
        //cc = 1111001
        
	cc = *(++pucObject5); //сместил указатель на 1 шаг и разименовывает его
        //01100110
	stop/* 
*/

	//Задание 7. Void-указатель. 
	//Выполняя задание, посмотрите - какие значения присваиваются
	//void-указателю. Обратите внимание: средствами отладчика Вы
	//не можете посмотреть значения, на которые "указывает"
	//void-указатель
	void*	pVoid;	//объявление void-указателя
	int	nObject3=5;
	char cObject3='A';
	int*	pInt = &nObject3;	
	pVoid=&nObject3;
	pVoid=&cObject3;
	pVoid=pInt;
	
	//Прежде, чем раскомментировать следующую строчку, вспомните:
	//что нужно сделать, чтобы выражение стало корректным 	
	pInt=static_cast< int*>(pVoid);

	//Что нужно сделать для того, чтобы следующее закомментированное выражение
	//стало корректным?
	{
		const int n = 1;
		const void *pn = &n;//????объявить слева void-указатель
	}



	//7a. При выполнении следующего фрагмента посмотрите, какие неприятности
	//могут Вас ожидать при явном приведении типа void-указателя,
	//который в момент времени (1) указывает на double, к типу 
	//указателя на int (2) 

	double dObject3 = 33.33;
	pVoid = &dObject3;	//(1)

	int nTmp = *(static_cast<int*>(pVoid) ); //(2) 
        std::cout << nTmp << "\n"; //1889785610
        //по всей вероятности мы пытаемся получить значение из
        //памяти в котором даюл перевеля по правилам целого
	stop
/**/
		//Задание 8. Модификатор const. В каждом из заданий
		//объявите указатель требуемого вида. Посредством каждого
		//указателя попробуйте:
		//получить значение по адресу
		//записать новое значение по адресу
		//модифицировать указатель

		//Задание 8a. Указатель является константой. 
        int varTest = 999, varTest2 = 1000;
        int  *const pTest = &varTest;
        std::cout << *pTest << "\n"; //значение по адресу
        *(const_cast<int*>(pTest)) = varTest2;
	
/*	stop	 
*/

		//Задание 8б. Указываемое значение является константой.
        const int varTestC = 999, varTestC2 = 1000;
        int *const pTest2 = const_cast<int*>(&varTestC);
        std::cout << *pTest2 << "\n"; //значение по адресу
        *(const_cast<int*>(pTest2)) = static_cast<int>(varTestC2);
	stop
/**/

		//Задание 8в. И указатель, и указываемое значение
		//являются константами. 
        const int *const pTest3 =  &varTestC;
        std::cout << *pTest3 << "\n"; //значение по адресу
        
        (*(const_cast<int*>(pTest3))) ++;
        std::cout << "varTestC:" << *pTest3 << "\n";
/*
	stop
*/

		//Задание 8г. Указатель на переменную, объявленную с
		//ключевым словом const. 
	const int nN = 1;

	//Объявите указатель и проинициализируйте его выражением - &nN	
        const int *pnN = &nN;
        
	stop
/**/


	//Задание 9.При выполнении задания обратите внимание на то,
	//как наглядно отладчик "раскрывает" конструкции типа
	//"указатель на указатель" и на способы получения конечного
	//объекта по таким "иерархическим" указателям
	int	n1=1;

    //Объявите указатель pn и проинициализируйте его так, чтобы он
	//"указывал" на n1
        int * pn = &n1;


    //Объявите указатель ppn и проинициализируйте его так, чтобы он
	//"указывал" на pn
        int ** ppn = &pn;

    //Объявите указатель pppn и проинициализируйте его так, чтобы он
	//"указывал" на ppn
        int *** pppn = &ppn;
  
	//С помощью указателей pn, ppn и ppn получите значение объекта n1
	//и присвойте его n2

	int n2= *pn + **ppn + ***pppn;
        
        std::cout << "n2: " << n2 << "\n"; //3
  /*
	stop
*/



	return 0;
}//end main
