
/*************************************************************
	Практическое занятие №5. 
	"Старые" потоковые функции стандартной библиотеки
	Указатели на функции
	Структуры
*************************************************************/
//#include <tchar.h>
#include <iostream>
#include <cstdio>
#include "other.h"



#define	  stop 

int main()
{
	//Тема "Старые" потоковые функции стандартной библиотеки
	//Задание 1. С помощью функции scanf сформирйуте три коэффициента: A,B,C
    int A,B,C;
    
    scanf("%d%d%d%*c", &A, &B, &C);
    std::cout << "A: " << A << "\n";
    std::cout << "B: " << B << "\n";
    std::cout << "C: " << C << "\n";

	//Задание 2. Выведите (красиво!) таблицу значений y=A*x*x + B*x + C
	//при изменении x в диапазоне -2 до +2 с шагом 0.5
	
    float x,y;
    for(x = -2; x <= 2; x += .5) {
        y=A*x*x + B*x + C;
        printf("y = %d * %4.2f * %4.2f + %d * %4.2f + %d = %4.2f\n",A, x, x, B, x, C, y);
    }


///////////////////////////////////////////////////////////////////
	//Тема Указатели на функции

	//Задание 1. Указатель на функцию. "Калькулятор".
	//Напишите функции:
	//1)Sum - принимает два значения double и возвращает сумму
	//этих значений
	//2)Sub- принимает два значения double и возвращает разность
	//этих значений
	//3)Mul - *
	//4)Div - /
	//5)а для возведения в степень можете использовать функцию стандартной библиотеки
	//		- pow(). Подсказка 1: прототип функции находится в <cmath>.
	//		Подсказка 2: стандартная библиотека предоставляет несколько перегруженных
	//		вариантов этой функции, а Вам потребуется сформировать указатель на 
	//		double pow(double, double);

	//Предоставьте пользователю	следующую возможность:
	//пока пользователь хочет пользоваться услугами Вашего калькулятора,
	//он может вводить два значения и знак операции
	//а Вы выводите результат. Результат получаете посредством вызова
	//соответствующей Вашей функции по указателю.
	//Предусмотрите возможность ввода непредусмотренного знака операции

        printf("Match(1, 1, +) = %f\n", Match(1, 1, PLUS));
        printf("Match(1, 1, -) = %f\n", Match(1, 1, MINUS));
	printf("Match(3, 2.1, *) = %f\n", Match(3, 2.1, MUL));
        printf("Match(3, 1.5, /) = %f\n", Match(3, 1.5, DIV));
        printf("Match(2, 8, **) = %f\n", Match(2, 8, POW));
	

	stop

	//Задание 2. Указатель на функцию в качестве аргумента.
	//Дана заготовка функции сортировки любых объектов - Sort.
	//Функция принимает следующие параметры:
	//1) указатель на первый сортируемый элемент
	//2) количество сортируемых элементов
	//3) размер элемента в байтах
	//4) указатель на функцию перестановки элементов
	//5) указатель на функцию сравнения элементов

	//2a. Напишите функцию перестановки двух целых значений -
	// SwapInt, которая принимает два void указателя и 
	//меняет значения местами

	//Напишите функцию сравнения двух целых значений -
	// CmpInt, которая принимает два void указателя и
	//возвращает int результат сравнения: 
	//<0 - первый элемент меньше, чем второй
	//=0 - равны
	//>0 - первый элемент больше, чем второй

	int nAr[5]= {28, 77, -1, 0, 888};	//массив для сортировки

	//Печать исходного массива
        for(int i = 0; i < 5; i ++) {
            std::cout << nAr[i] << ", ";
        }
        
        std::cout << "\n";


	//Вызов сортировки
	int nTotal=5;			//количество элементов в массиве 
	Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(int), SwapInt, CmpInt);
	
	//Печать результатов сортировки
        for(int i = 0; i < 5; i ++) {
            std::cout << nAr[i] << ", ";
        }
        
        std::cout << "\n";

	stop
/**/

	//Задание 2б. По аналогии с 8а создайте вспомогательные
	//функции - SwapDouble и CmpDouble и вызовите функцию Sort
	//для сортировки массива вещественных значений.
                
                
        double dAr[5]= {28.0, 77.0, -1.0, 0.1, 888.0};	//массив для сортировки

	//Печать исходного массива
        for(int i = 0; i < 5; i ++) {
            std::cout << dAr[i] << ", ";
        }
        
        std::cout << "\n";


	//Вызов сортировки 
	Sort(reinterpret_cast<char*>(&dAr[0]), nTotal, sizeof(double), SwapDouble, CmpDouble);
	
	//Печать результатов сортировки
        for(int i = 0; i < 5; i ++) {
            std::cout << dAr[i] << ", ";
        }
        
        std::cout << "\n";
/**/

	//Задание 2в*. По аналогии с 8а создайте вспомогательные
	//функции - SwapStr и CmpStr и вызовите функцию Sort 
	//для сортировки массива указателей на строки.
	char s[] = "QWERTY";
	const char* arStr[5] = {"WWW", "SDF", "ABC", &s[0], "Some"};
        for(int i = 0; i < 5; i ++) {
            std::cout << arStr[i] << ", ";
        }
        
        Sort(reinterpret_cast<char*>(&arStr[0]), nTotal, sizeof(const char*) / 2, SwapStr, CmpStr);
        for(int i = 0; i < 5; i ++) {
            std::cout << arStr[i] << ", ";
        }
        std::cout << "\n";
      //  return 0;
/**/
	

	//Задание 3. Массивы указателей на функцию.
	//Напишите несколько функций вида
	//const char* GetString1();
	//const char* GetString2();
	//		...., каждая из функций возвращает указатель на свою строку
	//(подумайте - какой адрес Вы имеете право возвращать из функции)
	
        
	//Объявите и проинициализируйте массив указателей на функции
	//GetString1,GetString2...
         
        const char* (*mas[2])() = {&GetString1, &GetString2}; 
	//Введите номер функции, которую Вы хотите вызвать:
	int n = 0; 
        //Вызовите функцию 
        for( ; n < 2; n ++) {
            const char* r = mas[n]();
            printf("%s \n", r);
        } 

	//Распечатайте результат

/*
*/
//////////////////////////////////////////////////////////////////////////////////////

	//Тема. Структуры С.	
	//Задание 1. Объявите структуру BOOK, описывающую книгу
	//(автор, заглавие, год издания, цена, категория…).
	//Подумайте: какого типа могут быть поля структуры.
	//Подсказка: объявление структуры рекомендуется выносить
	//в заголовочный файл.




	//Задание 2. Создайте разными способами (глобальный, локальный, статический,
	//динамический) экземпляры (объекты) типа BOOK (без инициализации).
	//Определите - сколько памяти отводит компилятор под каждый
	//такой объект. Как инициализируются (или не инициализируются) поля
	//структуры. Подумайте: от чего зависит объем выделяемой памяти?
        
        {
            static BOOK staticBook;
            
            //
            BOOK bs;   
            bs.year = 2017;
            bs.price = 14500.00;
            BookSetTitle(bs, "Some title sb");
            BookSetAuthor(bs, "J S");
            BookSetCategory(bs, "sss");
            
            //
            BOOK *pbs = new BOOK();
            pbs->year = 2017;
            pbs->price = 14500.00;
            BookSetTitle(*pbs, "Some title2");
            BookSetAuthor(*pbs, "Json Smit");
            BookSetCategory(*pbs, "sss");
            
            //
            globalBOOK.year = 2017;
            globalBOOK.price = 14500.00;
            BookSetTitle(globalBOOK, "Some title globalBOOK");
            BookSetAuthor(globalBOOK, "J s");
            BookSetCategory(globalBOOK, "ssssss");
            
            //
            staticBook.year = 2017;
            staticBook.price = 14500.00;
            BookSetTitle(staticBook, "Some title globalBOOK");
            BookSetAuthor(staticBook, "J s");
            BookSetCategory(staticBook, "ssssss");
            
            printf("Static sizeof: %lu \n", sizeof(staticBook));
            printBOOK(staticBook);
            printf("Global sizeof: %lu \n", sizeof(globalBOOK));
            printBOOK(globalBOOK);
            printf("Local sizeof: %lu \n", sizeof(bs));
            printBOOK(bs);
            printf("Dinamic sizeof: %lu \n", sizeof(*pbs));
            printBOOK(*pbs);
        }



	//Задание 3. Заполните поля созданных объектов.
	//Замечание: если для хранения строки используется массив, необходимо
	//предусмотреть "защиту" от выхода за границы массива.



	//Задание 4. Напишите функцию, выводящую на экран реквизиты книги.
	//Подумайте: как эффективнее передавать экземпляр BOOK в функцию.
	//Для вывода на консоль используйте функцию стандартной библиотеки
	//printf
        //printBOOK



	//Задание 5. Напишите функцию для формирования полей структуры.
	//Для ввода используйте функцию стандартной библиотеки scanf
	//Замечание: неплохо заложить в такую функцию возможность проверки
	//корректности введенного значения, например, год издания не может быть
	//меьше, чем... (год появления письменности), категорию ползователь
	//должен выбирать из существующих, цена не может быть отрицательной...
        
        BOOK *b1 = makeBook();
        printBOOK(*b1);
        delete b1;


	return 0;
}//main

