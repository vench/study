
/*************************************************************
	Практическое занятие №3. Функции.
	Объявление, определение, вызов.
	Передача параметров. Возвращение значения.
	Указатели на функции
*************************************************************/
#include <iostream>
//#include <tchar.h>
//#include <cstdio>
//#include <cstdarg>
#include "other.h"


#define	  stop 

int main()
{
	
	/////////////////////////////////////////////////////////////////////////////
	// Задание 1. Ссылки.
	//Объявите ссылку на тип double. Посредством ссылки измените значение
        
        double vd = 0.1;
        double &ref = vd;
        
        ref = 0.2;
        
        std::cout << ref << "\n";
        

	//Раскомментируйте две следующих строчки. Что следует сделать, чтобы
	//linker не выдавал ошибки при создании exe-файла Подсказка: ссылка ref
	//должна быть внешней
	
	refVal++;

        std::cout << ref << "\n";


	//Раскомментируйте следующую строку. Что следует сделать, чтобы
	//компилятор не выдавал ошибки 
        int n = 1;
	int&& ref1 = 8;



	//Задан указатель:
        char arc[2] = {'A', 'B'};
	char c=arc[0];
	char* pc = &arc[0]; //что бы убедится что адрес сместился
	//Объявите ссылку на указатель. Посредством ссылки измените
	//а) значение по адресу
	//б) сам адрес
        char *&pcref = pc;
        *pcref = 'C';
        std::cout << *pcref << "\n";
        pcref++;
        std::cout << *pcref << "\n";
        
	
/**/
	

	//Задание 2. Отличия при передаче параметров а) по значению,
	// б) по ссылке, в) по указателю
	//Объявите и определите три функции , которые увеличивают заданное
	//с помощью параметра значение на 1 ( а) - IncByValue(),
	// б) - IncByPointer(), в) - IncByReference() ). 
	//Проверьте правильность с помощью отладчика.
	//
	//Замечание: объявления функций принято помещать в заголовочный файл
	int val =1;//значение этой переменной должно быть увеличено с помощью
				//каждой из функций на единицу
        
        val = IncByValue(val);
       // std::cout << "IncByValue: " << val << "\n";
        IncByPointer(&val);
        //std::cout << "IncByPointer: " << val << "\n";
        IncByReference(val);         
        //std::cout << "IncByReference: " << val << "\n";
        
  
	stop


	//Задание 2а. Передача параметров c помощью указателя и по ссылке. 
	//Перегруженные имена функций.
	//Создайте функцию (функции) Swap(), которая меняет значения
	//переменных nX и nY местами. 
	// а)Функция должна принимать два указателя на int, оперируя с 
	//которыми менять значения переменных в вызывающей программе
	// б)Функция должна принимать две ссылки на int 
	//Проверьте правильность с помощью приведенного ниже фрагмента.

	int	nX = 1;
	int nY = -1;
	Swap(&nX  ,  &nY);	//поменяли местами значения nX и nY с
       // std::cout << "(1)nX: " << nX << " (-1)nY: " << nY << "\n";
						//помощью указателей на nX и nY
	Swap(nX  ,  nY);	//а теперь обратно с помощью ссылок на nX и nY
       // std::cout << "(1)nX: " << nX << " (-1)nY: " << nY << "\n";
	stop
/**/

	//Задание 3. Указатели на массивы в качестве аргументов.
	//3a.Напишите два варианта функции поиска минимального элемента
	//1. во встроенном двухмерном массиве
	//2. в динамическом двухмерном массиве (обе размерности вычисляются)
	
	//1.Например:
                
	int ar[N][M] = {{1,2,-3}, {4,0,6}};//подумайте - как и где должны быть заданы N и M
	int res = Min(ar); 
        
        std::cout << res << "\n";
        
        int rows = 5, cols = 10; 
        
        
        int **par = new int*[rows];
        //init
        for (int i = 0; i < rows; i ++) {
            par[i] = new int[cols]; 
            for(int j = 0; j < cols; j ++) {
                par[i][j] = i + j * ( (i + j) % 2 == 0 ? -1 : 1 );
                
                std::cout << "par[i][j]: " << par[i][j] << "\n";
                
            }
        }
        
        res = Min(par, rows, cols);
        
        for (int i = 0; i < rows; i ++) {
            
            delete[] par[i];
        }
        delete[] par;
        std::cout << res << "\n";
        
        
/**/

	//3b. Напишите функцию сравнения двух строк - MyStrCmp():
	//Функция должна принимать два указателя на сравниваемые
	//строки (возможно Вы должны указать компилятору, что функция
	//не имеет права модифицировать содержимое строк)
	//Функция должна возвращать отрицательное значение, если
	//первая строка лексиграфически меньше второй, 0 - если
	//они равны и положительное значение, если первая строка
	//больше второй.
	//Вспомните, что признаком конца строки является нулевой байт.

	
	//Создайте две строки для сравнения: 
        const char* s1 = "ABC";
        const char* s2 = "XYZZZ";
	//Вызовите функцию сравнения
        int r1 = MyStrCmp(s1, s2);//-1
        int r2 = MyStrCmp(s1, s1);//0
        int r3 = MyStrCmp(s2, s1);//1
        
	
	//Выведите результат сравнения с помощью cout:
        
        std::cout << r1 << " : " << r2 << " : " << r3 << "\n";
/*
	stop
*/

	//Задание 4.Ссылки в качестве параметров. Передача указателя на встроенный
	//массив в качестве параметра функции.
	//Напишите две взаимодополняющие друг друга функции:
	//1.  ... DayOfYear(...)
	//- преобразует день месяца (число,месяц и год задаются в качестве параметров)
	//в порядковый день года(возвращаемое значение)
	//2. ... DayOfMonth(...) - функция преобразует порядковый день года в день месяца
	// (принимает год и порядковый день года в качестве параметров и должна сформировать
	// день месяца и номер месяца и каким-то образом сообщить эти значения вызывающей процедуре)
	
	//Проверьте работоспособность обеих функций с помощью следующего фрагмента:
	

	//В процессе вычислений Вам придется учитывать "високосный - невисокосный" год.
	//Для этого предлагается в каждую функцию в качестве одного из параметров передавать
	//данные приведенного ниже двухмерного массива nDayTab

	int nDayTab[2][12]={
		{31,28,31,30,31,30,31,31,30,31,30,31}, //невисокосный год
		{31,29,31,30,31,30,31,31,30,31,30,31}	};	//високосный год
	
	//Вызов функции DayOfYear
	//...

        std::cout << "DayOfYear(1,1,2017)=1 => " << DayOfYear(1,1,2017, nDayTab) << "\n";
        std::cout << "DayOfYear(6,4,2016)=97 => " << DayOfYear(6,4,2016, nDayTab) << "\n";
        
//
	//Проверка результата обратной функцией DayOfMonth
	int *rd1 =  DayOfMonth(97, 2016, nDayTab);
        int *rd2 =  DayOfMonth(1, 2017, nDayTab);
        
        std::cout << "DayOfMonth(97, 2016), Day(6): " << rd1[0] << ", Month(4): " << rd1[1] << "\n";
        std::cout << "DayOfMonth(1, 2017), Day(1): " << rd2[0] << ", Month(1): " << rd2[1] << "\n";
        
        delete[] rd1;
        delete[] rd2;

	stop
/**/
	//Задание 5. Создайте одномерный массив (размерность вычисляется в процессе
	//выполнения программы), заполните его значениями.
	//Напишите функцию, которая добавляет в массив ервре значение только при
	//условии, что такого значения в массиве еще нет. Подсказка: при этом размер
	//массива должен увеличиться! Функция НЕ ДОЛЖНА ничего возвращать.
        int size = 1;
        int *dar = new int[size];
        dar[0] = 998;
        
        
	//Для проверки напишите функцию, которая выводит значения всех элементов на экран
        int inputInt;
        std::cout << "Заполняем dar: " << "\n";
        while (std::cin >> inputInt && inputInt != 0) {
            size = appendAr(dar, size, inputInt); 
        }
        
        for(int n = 0; n < size; n ++) {
            std::cout << "ar: " << dar[n] << "\n"; 
        }
        
        delete[] dar;


	//Задание 6. Рекурсивные функции. Напишите рекурсивную функцию вычисления
	//суммы первых N натуральных чисел.

        int rn =  naturalSum(3);
        std::cout << "rn: naturalSum(3) = 6: " << rn << "\n";
/**/

	//Задание 7а. Функции с переменным числом параметров.
	//Напишите функцию (дана заготовка VarArgs, не использующая
	// макросы), которая принимает переменное число аргументов
	// типа int и выводит на печать число принятых параметров и
	// их значения.
	// Признаком конца списка является нулевое значение.
	
        
        //FIX!
	int nN1=5, nN2=11, nN3=4, nN4=7, nN5=-1;/**/  
	VarArgs(nN1,0);	
	VarArgs(nN1,nN2,0);	
	VarArgs(nN1,nN2,nN3,nN4,nN5,0);	
      
        
	stop


	//Задание 7б. Модифицируйте функцию 5а с помощью макросов
	// va_start, va_arg, va_end
/**/
        //FIX        
        VarArgs2(nN1,0);	
	VarArgs2(nN1,nN2,0);	
	VarArgs2(nN1,nN2,nN3,nN4,nN5,0);


	//Задание 8. Возвращение адреса.
	//Напишите функцию, которая находит минимальное значение в массиве,
	// таким образом, чтобы ее вызов можно было использовать слева от знака 
	// равенства: *MyMin(параметры) = 0;
	int arNum[5] = {1, 5,-1,0,100};
        *MyMin(&arNum[0], 5) = 0; 
        std::cout << arNum[2] << "\n";
        
        
	return 0;
}//main

